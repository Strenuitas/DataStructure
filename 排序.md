# BubbleSort 冒泡排序

思路：从第一个数开始依次与相邻数字比较，选择大的往后移，到数组末尾的时候，最后一位就是当前最大的数。这是一次冒泡的过程，以此类推，需要冒泡n-1次。
可以加一个标志位，提前结束循环，即如果一次冒泡的过程中没有发生交换，也就是已经有序了，我们就可以提前结束循环，若是排好序的数组，我们只需要比较n-1次即可。最好的时间复杂度为O(n)

# SelectionSort 选择排序

思路：在未排序好的数组中找到最小或最大元素，放到初始位置，然后在剩余的未排好序的数组中接着找最小或最大，接着放到它的初始位置，一直在剩余数组剩一个。感觉像是递归的思想，


# 插入排序

思路：和打扑克牌一样，在未排序的数组中插入一个数，并把它放到该在的位置，例如  3,1,5,2,1   3一开始排好序了，后面的数字就要往前3所在的这一数组里面插入，与3进行比较，如果比它大就放到后面若是比它小，3就要后移，后面的数字插入到3的前面即可。所以我们可以一边比较一边移动，  
也就是排好序的数组从后往前一个一个和要插入的数字进行比较，若是比它大，则往后移动一位，若是比它小，则它就插入到当前比较的数字的后面即可。
```
public static int[] insertionSort(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            int cur = arr[i];
            int preCur  = i - 1;
            while (preCur >= 0 && arr[preCur] > cur  ){
                arr[preCur + 1] = arr[preCur];
                preCur--;
            }
            arr[preCur + 1] = cur;
        }
        return arr;
    }
```
