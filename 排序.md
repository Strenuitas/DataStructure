# BubbleSort 冒泡排序

思路：从第一个数开始依次与相邻数字比较，选择大的往后移，到数组末尾的时候，最后一位就是当前最大的数。这是一次冒泡的过程，以此类推，需要冒泡n-1次。
可以加一个标志位，提前结束循环，即如果一次冒泡的过程中没有发生交换，也就是已经有序了，我们就可以提前结束循环，若是排好序的数组，我们只需要比较n-1次即可。最好的时间复杂度为O(n)

# SelectionSort 选择排序

思路：在未排序好的数组中找到最小或最大元素，放到初始位置，然后在剩余的未排好序的数组中接着找最小或最大，接着放到它的初始位置，一直在剩余数组剩一个。感觉像是递归的思想，


# 插入排序

思路：和打扑克牌一样，在未排序的数组中插入一个数，并把它放到该在的位置，例如  3,1,5,2,1   3一开始排好序了，后面的数字就要往前3所在的这一数组里面插入，与3进行比较，如果比它大就放到后面若是比它小，3就要后移，后面的数字插入到3的前面即可。所以我们可以一边比较一边移动，  
也就是排好序的数组从后往前一个一个和要插入的数字进行比较，若是比它大，则往后移动一位，若是比它小，则它就插入到当前比较的数字的后面即可。
```
public static int[] insertionSort(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            int cur = arr[i];
            int preCur  = i - 1;
            while (preCur >= 0 && arr[preCur] > cur  ){
                arr[preCur + 1] = arr[preCur];
                preCur--;
            }
            arr[preCur + 1] = cur;
        }
        return arr;
    }
```

# 归并排序
思路：将原始数组划分成两个子数组进行排序，排好序的子数组再合并即是结果，这样可以一直划分直到子数组长度为<=1，划分条件是每次数组长度/2,作为middle 然后利用    Arrays.copyOfRange(arr,start,end) 包括start 不包括end,  分为 arr(0,middle) arr(middle,end),两个再进行合并.  
合并排好序的数组，先创建一个大数组存储合并后的数字，每次对数组第一个数字进行比较，小的放进去，且小的那一个索引向后，继续与另一个进行比较，直到一个数组为空    
一个数组为空，在后面加上另一个数组的剩余元素，如果两个数组都为空，则直接结束。


# 快速排序
和归并排序一个原理，不过是多了一个步骤，小的在一边，大的在另一边，少去了最后合并的过程。  具体步骤：  
1：确定一个基准元素，将比它大的放在右边，比它小的放在左边，分成左右两个数组
2：接着在左 右数组进行和2一样的步骤
3：直到左右数组都为1的时候，递归结束，向上迭代。  
``` 
